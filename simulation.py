"""
Simulation script for AG-inspired quantum error-correcting codes.

This module implements a physics‑driven noise model tailored to hollow‑core
fibres (HCF) carrying both quantum and classical channels, includes a
first‑order Markov model for temporal correlations, and estimates the
logical block error probability of a CSS code under asymmetric Pauli noise.

The model parameters—fibre length, classical launch power, wavelength
separation, Raman and FWM coefficients, attenuation and correlation
strength—can be adjusted via function arguments.  The main entry point,
``run_default_demo``, executes a Monte Carlo simulation for the standard
[[255,33,21]] AG code over a 100 km fibre with 10 dBm co‑propagating
classical power and prints the derived asymmetric error probabilities,
estimated block error probability and entanglement fidelity.

This script accompanies the improved simulation methodology described in
Section~\ref{sec:enhancements} of the paper.  The algorithm proceeds as
follows:

1. Convert the classical launch power from dBm to Watts and compute the
   effective power after propagation through the fibre using an exponential
   attenuation model.
2. Compute the mean number of noise photons generated by spontaneous Raman
   scattering (SpRS) and four‑wave mixing (FWM) using experimentally
   calibrated coefficients.  A phase (Z) error occurs if at least one
   noise photon arrives within the qubit time bin; for small photon
   numbers this probability is $1-e^{-(N_{\mathrm{SpRS}}+N_{\mathrm{FWM}})}$.
3. Model amplitude (X) errors as a fixed fraction ``eta_px`` of the phase
   error probability.  A Y error corresponds to simultaneous X and Z flips
   and has probability half the sum of X and Z probabilities.
4. Generate correlated error patterns for X and Z errors separately via a
   two‑state Markov process: the hidden state persists with probability
   ``correlation_strength`` and flips with probability ``1-correlation_strength``;
   in the high‑noise state the base error rate doubles.
5. Repeat steps 2–4 over many Monte Carlo trials; in each trial count
   the number of X and Z errors and record a block failure if either
   exceeds the code’s correctable threshold ``t``.  The estimated block
   error probability is the ratio of failures to trials, and the
   entanglement fidelity is $F_e \approx 1-P_L$ for a CSS code.

To execute the demo, run this file directly with Python 3.  Adjust the
parameters or call the helper functions as needed to explore different
scenarios.  Increasing the number of trials improves the statistical
accuracy at the cost of longer runtime.
"""

import math
import random
from typing import Dict, Sequence


def hcf_noise_model(
    length_km: float,
    classical_power_dBm: float,
    wavelength_separation_nm: float,
    raman_coeff: float = 0.11,
    fwm_coeff: float = 1e-4,
    attenuation_db_per_km: float = 0.25,
    eta_px: float = 0.3,
) -> Dict[str, float]:
    """Translate physical parameters into asymmetric Pauli error probabilities.

    Args:
        length_km: Fibre length in kilometres.
        classical_power_dBm: Launch power of the classical channel in dBm.
        wavelength_separation_nm: Spectral separation between quantum and
            classical channels (in nm).
        raman_coeff: Coefficient relating classical power to broadband SpRS
            noise photons (units W⁻¹·km⁻¹).
        fwm_coeff: Coefficient relating classical power to FWM noise photons
            (units W⁻²·km⁻²).
        attenuation_db_per_km: Fibre attenuation in dB per kilometre.
        eta_px: Ratio of amplitude (X) error probability to phase (Z) error
            probability.

    Returns:
        A dictionary with keys 'p_x', 'p_y' and 'p_z' giving the respective
        Pauli error probabilities per qubit.
    """
    # Convert classical launch power from dBm to Watts
    classical_power_w = 10 ** ((classical_power_dBm - 30) / 10.0)
    # Compute effective power after propagation: exponential decay
    effective_power = classical_power_w * math.exp(
        -attenuation_db_per_km * 0.1 * length_km
    )
    # Mean noise photons from SpRS and FWM processes
    sprs_photons = raman_coeff * effective_power * length_km
    fwm_photons = fwm_coeff * (effective_power ** 2) * wavelength_separation_nm
    # Phase (Z) error probability: probability of at least one noise photon
    p_z = 1.0 - math.exp(-(sprs_photons + fwm_photons))
    # Amplitude (X) error probability assumed to be a fraction of p_z
    p_x = eta_px * p_z
    # Y error probability: simultaneous X and Z; taken as half the sum
    p_y = 0.5 * (p_x + p_z)
    return {"p_x": p_x, "p_y": p_y, "p_z": p_z}


def markov_correlated_errors(
    p_base: float, correlation_strength: float, n_qubits: int
) -> Sequence[int]:
    """Generate a binary error pattern with first‑order Markov correlations.

    Each qubit is associated with a hidden noise state (0 for low noise,
    1 for high noise).  In the high-noise state the error probability is
    doubled.  The hidden state persists with probability ``correlation_strength``
    and flips otherwise.

    Args:
        p_base: Base error probability when the hidden state is low noise.
        correlation_strength: Probability of remaining in the same hidden state.
        n_qubits: Number of qubits (length of the pattern).

    Returns:
        A list of integers of length ``n_qubits`` with 1 denoting an error.
    """
    errors = [0] * n_qubits
    state = 0
    for i in range(n_qubits):
        # Determine current error probability
        prob = p_base if state == 0 else min(1.0, 2 * p_base)
        errors[i] = 1 if random.random() < prob else 0
        # Update hidden state: stay with probability correlation_strength
        if random.random() > correlation_strength:
            state ^= 1  # flip between 0 and 1
    return errors


def monte_carlo_block_error_asymmetric(
    n: int,
    t: int,
    p_x: float,
    p_z: float,
    correlation_strength: float,
    trials: int = 10000,
) -> float:
    """Estimate block error probability for asymmetric, correlated errors.

    For each trial this function generates a correlated X-error pattern and
    a correlated Z-error pattern of length ``n`` using the Markov model.  A
    block failure is recorded if the number of X errors or Z errors
    exceeds the correctable threshold ``t``.  Y errors are not simulated
    separately since in CSS codes a Y error corresponds to simultaneous X
    and Z flips.

    Args:
        n: Block length (number of physical qubits).
        t: Correctable threshold (floor((d-1)/2)).
        p_x: Base amplitude error probability per qubit.
        p_z: Base phase error probability per qubit.
        correlation_strength: Markov correlation parameter (0 = i.i.d.).
        trials: Number of Monte Carlo trials.

    Returns:
        Estimated probability that the block error exceeds the correctable
        threshold (logical failure probability).
    """
    failures = 0
    for _ in range(trials):
        # Generate correlated error patterns for X and Z separately
        x_errors = markov_correlated_errors(p_x, correlation_strength, n)
        z_errors = markov_correlated_errors(p_z, correlation_strength, n)
        # Count number of errors
        if sum(x_errors) > t or sum(z_errors) > t:
            failures += 1
    return failures / float(trials)


def run_default_demo() -> None:
    """Run a demonstration simulation for the [[255,33,21]] AG code.

    This function computes asymmetric error probabilities for a 100 km HCF
    carrying a 10 dBm classical signal with 5 nm wavelength separation,
    generates correlated error patterns with correlation strength 0.6 and
    estimates the block error probability via Monte Carlo sampling with
    10 000 trials.  Results are printed to the console.
    """
    # Code parameters
    n, k, d = 255, 33, 21
    t = (d - 1) // 2
    # Physical parameters
    length_km = 100.0
    classical_power_dBm = 10.0
    wavelength_separation_nm = 5.0
    # Compute error probabilities
    probs = hcf_noise_model(length_km, classical_power_dBm, wavelength_separation_nm)
    p_x, p_z = probs["p_x"], probs["p_z"]
    print(
        f"Derived probabilities for length={length_km} km, P_classical={classical_power_dBm} dBm, Δλ={wavelength_separation_nm} nm:"
    )
    print(f"  p_z ≈ {p_z:.5f}, p_x ≈ {p_x:.5f}")
    # Correlation strength (ρ)
    rho = 0.6
    # Run Monte Carlo to estimate block error
    p_L = monte_carlo_block_error_asymmetric(n, t, p_x, p_z, rho, trials=10000)
    F_e = 1.0 - p_L
    print(f"Estimated logical block error probability P_L ≈ {p_L:.3e}")
    print(f"Estimated entanglement fidelity F_e ≈ {F_e:.4f}")


if __name__ == "__main__":
    run_default_demo()